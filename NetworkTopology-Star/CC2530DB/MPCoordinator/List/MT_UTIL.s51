///////////////////////////////////////////////////////////////////////////////
//
// IAR C/C++ Compiler V9.30.3.3983 for 8051               25/Apr/2017  12:05:44
// Copyright 2004-2016 IAR Systems AB.
// Standalone license - IAR Embedded Workbench for 8051
//
//    Core               =  plain
//    Code model         =  banked
//    Data model         =  large
//    Calling convention =  xdata reentrant
//    Constant location  =  data_rom
//    Dptr setup         =  1,16
//                          
//    Source file        =  
//        C:\Texas
//        Instruments\ZStack-CC2530-2.4.0-1.4.0\Components\mt\MT_UTIL.c
//    Command line       =  
//        -f "C:\Texas
//        Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\NetworkTopology-Star\CC2530DB\..\..\..\Tools\CC2530DB\f8wCoord.cfg"
//        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
//        -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8 -DMAC_CFG_RX_MAX=5
//        -DZDO_COORDINATOR -DRTR_NWK) -f "C:\Texas
//        Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\NetworkTopology-Star\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig-top.cfg"
//        (-DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
//        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0x2100
//        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
//        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
//        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
//        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
//        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
//        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
//        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
//        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
//        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
//        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
//        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=TRUE
//        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)
//        -DREJOIN_POLL_RATE=440 "C:\Texas
//        Instruments\ZStack-CC2530-2.4.0-1.4.0\Components\mt\MT_UTIL.c" -D
//        HOLD_AUTO_START -D BUILD_ALL_DEVICES -D REFLECTOR -D NV_INIT -D
//        xNV_RESTORE -D ZTOOL_P1 -D MT_TASK -D MT_SYS_FUNC -D xMT_SAPI_FUNC -D
//        xMT_SAPI_CB_FUNC -D STARTEST -D LCD_USE -lC "C:\Texas
//        Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\NetworkTopology-Star\CC2530DB\MPCoordinator\List"
//        -lA "C:\Texas
//        Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\NetworkTopology-Star\CC2530DB\MPCoordinator\List"
//        --diag_suppress Pe001,Pa010 -o "C:\Texas
//        Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\NetworkTopology-Star\CC2530DB\MPCoordinator\Obj"
//        -e --no_code_motion --debug --core=plain --dptr=16,1
//        --data_model=large --code_model=banked
//        --calling_convention=xdata_reentrant --place_constants=data_rom
//        --nr_virtual_regs 8 -I "C:\Texas
//        Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\NetworkTopology-Star\CC2530DB\"
//        -I "C:\Texas
//        Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\NetworkTopology-Star\CC2530DB\..\Source\"
//        -I "C:\Texas
//        Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\NetworkTopology-Star\CC2530DB\..\..\..\ZMain\TI2530DB\"
//        -I "C:\Texas
//        Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\NetworkTopology-Star\CC2530DB\..\..\..\..\..\Components\hal\include\"
//        -I "C:\Texas
//        Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\NetworkTopology-Star\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\"
//        -I "C:\Texas
//        Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\NetworkTopology-Star\CC2530DB\..\..\..\..\..\Components\mac\include\"
//        -I "C:\Texas
//        Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\NetworkTopology-Star\CC2530DB\..\..\..\..\..\Components\mac\high_level\"
//        -I "C:\Texas
//        Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\NetworkTopology-Star\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\"
//        -I "C:\Texas
//        Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\NetworkTopology-Star\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
//        -I "C:\Texas
//        Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\NetworkTopology-Star\CC2530DB\..\..\..\..\..\Components\mt\"
//        -I "C:\Texas
//        Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\NetworkTopology-Star\CC2530DB\..\..\..\..\..\Components\osal\include\"
//        -I "C:\Texas
//        Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\NetworkTopology-Star\CC2530DB\..\..\..\..\..\Components\osal\mcu\ccsoc\"
//        -I "C:\Texas
//        Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\NetworkTopology-Star\CC2530DB\..\..\..\..\..\Components\services\saddr\"
//        -I "C:\Texas
//        Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\NetworkTopology-Star\CC2530DB\..\..\..\..\..\Components\services\sdata\"
//        -I "C:\Texas
//        Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\NetworkTopology-Star\CC2530DB\..\..\..\..\..\Components\stack\af\"
//        -I "C:\Texas
//        Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\NetworkTopology-Star\CC2530DB\..\..\..\..\..\Components\stack\nwk\"
//        -I "C:\Texas
//        Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\NetworkTopology-Star\CC2530DB\..\..\..\..\..\Components\stack\sapi\"
//        -I "C:\Texas
//        Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\NetworkTopology-Star\CC2530DB\..\..\..\..\..\Components\stack\sec\"
//        -I "C:\Texas
//        Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\NetworkTopology-Star\CC2530DB\..\..\..\..\..\Components\stack\sys\"
//        -I "C:\Texas
//        Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\NetworkTopology-Star\CC2530DB\..\..\..\..\..\Components\stack\zdo\"
//        -I "C:\Texas
//        Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\NetworkTopology-Star\CC2530DB\..\..\..\..\..\Components\zmac\"
//        -I "C:\Texas
//        Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\NetworkTopology-Star\CC2530DB\..\..\..\..\..\Components\zmac\f8w\"
//        -Ohz --require_prototypes
//    List file          =  
//        C:\Texas
//        Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\NetworkTopology-Star\CC2530DB\MPCoordinator\List\MT_UTIL.s51
//
///////////////////////////////////////////////////////////////////////////////

        NAME MT_UTIL

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__calling_convention", "xdata_reentrant"
        RTMODEL "__code_model", "banked"
        RTMODEL "__core", "plain"
        RTMODEL "__data_model", "large"
        RTMODEL "__dptr_size", "16"
        RTMODEL "__extended_stack", "disabled"
        RTMODEL "__location_for_constants", "data"
        RTMODEL "__number_of_dptrs", "1"
        RTMODEL "__rt_version", "1"

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)


        END
// C:\Texas Instruments\ZStack-CC2530-2.4.0-1.4.0\Components\mt\MT_UTIL.c
//    1 /***************************************************************************************************
//    2   Filename:       MT_UTIL.c
//    3   Revised:        $Date: 2010-07-22 12:46:26 -0700 (Thu, 22 Jul 2010) $
//    4   Revision:       $Revision: 23106 $
//    5 
//    6   Description:    MonitorTest Utility Functions
//    7 
//    8   Copyright 2007-2010 Texas Instruments Incorporated. All rights reserved.
//    9 
//   10   IMPORTANT: Your use of this Software is limited to those specific rights
//   11   granted under the terms of a software license agreement between the user
//   12   who downloaded the software, his/her employer (which must be your employer)
//   13   and Texas Instruments Incorporated (the "License").  You may not use this
//   14   Software unless you agree to abide by the terms of the License. The License
//   15   limits your use, and you acknowledge, that the Software may not be modified,
//   16   copied or distributed unless embedded on a Texas Instruments microcontroller
//   17   or used solely and exclusively in conjunction with a Texas Instruments radio
//   18   frequency transceiver, which is integrated into your product.  Other than for
//   19   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   20   works of, modify, distribute, perform, display or sell this Software and/or
//   21   its documentation for any purpose.
//   22 
//   23   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   24   PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   25   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   26   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   27   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   28   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   29   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   30   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   31   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   32   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   33   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   34 
//   35   Should you have any questions regarding your right to use this Software,
//   36   contact Texas Instruments Incorporated at www.TI.com.
//   37 
//   38  ***************************************************************************************************/
//   39 
//   40 /***************************************************************************************************
//   41  * INCLUDES
//   42  ***************************************************************************************************/
//   43 #include "ZComDef.h"
//   44 
//   45 #include "AddrMgr.h"
//   46 
//   47 #include "OnBoard.h"   /* This is here because of the key reading */
//   48 #include "hal_key.h"
//   49 #include "hal_led.h"
//   50 #include "OSAL_Nv.h"
//   51 #include "osal.h"
//   52 #include "NLMEDE.h"
//   53 #include "MT.h"
//   54 #include "MT_UTIL.h"
//   55 #include "MT_MAC.h"
//   56 #include "ssp.h"
//   57 #if defined ZCL_KEY_ESTABLISH
//   58 #include "zcl_key_establish.h"
//   59 #endif
//   60 #if defined TC_LINKKEY_JOIN
//   61 #include "zcl_se.h"
//   62 #endif
//   63 
//   64 #if !defined NONWK
//   65 #include "MT_ZDO.h"
//   66 #include "MT_SAPI.h"
//   67 #include "MT_NWK.h"
//   68 #include "MT_AF.h"
//   69 #include "AssocList.h"
//   70 #include "ZDApp.h"
//   71 #endif
//   72 /***************************************************************************************************
//   73  * CONSTANTS
//   74  ***************************************************************************************************/
//   75 #define MT_UTIL_DEVICE_INFO_RESPONSE_LEN 14
//   76 #define MT_UTIL_STATUS_LEN    1
//   77 #define MT_UTIL_FRM_CTR_LEN   4
//   78 // Status + LinkKeyDataLen + Tx+Rx Frame counter.
//   79 #define MT_APSME_LINKKEY_GET_RSP_LEN (MT_UTIL_STATUS_LEN + SEC_KEY_LEN + (MT_UTIL_FRM_CTR_LEN * 2))
//   80 // Status + NV id
//   81 #define MT_APSME_LINKKEY_NV_ID_GET_RSP_LEN (MT_UTIL_STATUS_LEN + 2)
//   82 
//   83 /***************************************************************************************************
//   84  * LOCAL VARIABLES
//   85  ***************************************************************************************************/
//   86 #if defined ZCL_KEY_ESTABLISH
//   87 uint8 zcl_key_establish_task_id;
//   88 #endif
//   89 
//   90 /***************************************************************************************************
//   91  * LOCAL FUNCTIONS
//   92  ***************************************************************************************************/
//   93 #ifdef AUTO_PEND
//   94 static void MT_UtilRevExtCpy( uint8 *pDst, uint8 *pSrc );
//   95 static void MT_UtilSpi2Addr( zAddrType_t *pDst, uint8 *pSrc );
//   96 #endif
//   97 
//   98 #if defined (MT_UTIL_FUNC)
//   99 void MT_UtilGetDeviceInfo(void);
//  100 void MT_UtilGetNvInfo(void);
//  101 void MT_UtilSetPanID(uint8 *pBuf);
//  102 void MT_UtilSetChannels(uint8 *pBuf);
//  103 void MT_UtilSetSecLevel(uint8 *pBuf);
//  104 void MT_UtilSetPreCfgKey(uint8 *pBuf);
//  105 void MT_UtilCallbackSub(uint8 *pData);
//  106 void MT_UtilKeyEvent(uint8 *pBuf);
//  107 void MT_UtilTimeAlive(void);
//  108 void MT_UtilLedControl(uint8 *pBuf);
//  109 void MT_UtilSrcMatchEnable (uint8 *pBuf);
//  110 void MT_UtilSrcMatchAddEntry (uint8 *pBuf);
//  111 void MT_UtilSrcMatchDeleteEntry (uint8 *pBuf);
//  112 void MT_UtilSrcMatchCheckSrcAddr (uint8 *pBuf);
//  113 void MT_UtilSrcMatchAckAllPending (uint8 *pBuf);
//  114 void MT_UtilSrcMatchCheckAllPending (uint8 *pBuf);
//  115 
//  116 #if !defined NONWK
//  117 void MT_UtilDataReq(uint8 *pBuf);
//  118 static void MT_UtilAddrMgrExtAddrLookup(uint8 *pBuf);
//  119 static void MT_UtilAddrMgrEntryLookupNwk(uint8 *pBuf);
//  120 #if defined MT_SYS_KEY_MANAGEMENT
//  121 static void MT_UtilAPSME_LinkKeyDataGet(uint8 *pBuf);
//  122 static void MT_UtilAPSME_LinkKeyNvIdGet(uint8 *pBuf);
//  123 #endif //MT_SYS_KEY_MANAGEMENT
//  124 static void MT_UtilAssocCount(uint8 *pBuf);
//  125 static void MT_UtilAssocFindDevice(uint8 *pBuf);
//  126 static void MT_UtilAssocGetWithAddress(uint8 *pBuf);
//  127 static void packDev_t(uint8 *pBuf, associated_devices_t *pDev);
//  128 #if defined ZCL_KEY_ESTABLISH
//  129 static void MT_UtilzclGeneral_KeyEstablish_InitiateKeyEstablishment(uint8 *pBuf);
//  130 static void MT_UtilzclGeneral_KeyEstablishment_ECDSASign(uint8 *pBuf);
//  131 #endif // ZCL_KEY_ESTABLISH
//  132 static void MT_UtilSync(void);
//  133 #endif // !defined NONWK
//  134 #endif // MT_UTIL_FUNC
//  135 
//  136 #if defined (MT_UTIL_FUNC)
//  137 /***************************************************************************************************
//  138  * @fn      MT_UtilProcessing
//  139  *
//  140  * @brief   Process all the DEBUG commands that are issued by test tool
//  141  *
//  142  * @param   pBuf  - pointer to received SPI data message
//  143  *
//  144  * @return  status
//  145  ***************************************************************************************************/
//  146 uint8 MT_UtilCommandProcessing(uint8 *pBuf)
//  147 {
//  148   uint8 status = MT_RPC_SUCCESS;
//  149 
//  150   switch (pBuf[MT_RPC_POS_CMD1])
//  151   {
//  152 // CC253X MAC Network Processor does not have NV support    
//  153 #if !defined(CC253X_MACNP)
//  154     case MT_UTIL_GET_DEVICE_INFO:
//  155       MT_UtilGetDeviceInfo();
//  156       break;
//  157 
//  158     case MT_UTIL_GET_NV_INFO:
//  159       MT_UtilGetNvInfo();
//  160       break;
//  161 
//  162     case MT_UTIL_SET_PANID:
//  163       MT_UtilSetPanID(pBuf);
//  164       break;
//  165 
//  166     case MT_UTIL_SET_CHANNELS:
//  167       MT_UtilSetChannels(pBuf);
//  168       break;
//  169 
//  170     case MT_UTIL_SET_SECLEVEL:
//  171       MT_UtilSetSecLevel(pBuf);
//  172       break;
//  173 
//  174     case MT_UTIL_SET_PRECFGKEY:
//  175       MT_UtilSetPreCfgKey(pBuf);
//  176       break;
//  177 #endif
//  178     case MT_UTIL_CALLBACK_SUB_CMD:
//  179       MT_UtilCallbackSub(pBuf);
//  180       break;
//  181 
//  182     case MT_UTIL_KEY_EVENT:
//  183 #if (defined HAL_KEY) && (HAL_KEY == TRUE)
//  184       MT_UtilKeyEvent(pBuf);
//  185 #endif
//  186       break;
//  187 
//  188     case MT_UTIL_TIME_ALIVE:
//  189       MT_UtilTimeAlive();
//  190       break;
//  191 
//  192     case MT_UTIL_LED_CONTROL:
//  193 #if (defined HAL_LED) && (HAL_LED == TRUE)
//  194       MT_UtilLedControl(pBuf);
//  195 #endif
//  196       break;
//  197 
//  198     case MT_UTIL_SRC_MATCH_ENABLE:
//  199       MT_UtilSrcMatchEnable(pBuf);
//  200       break;
//  201 
//  202     case MT_UTIL_SRC_MATCH_ADD_ENTRY:
//  203       MT_UtilSrcMatchAddEntry(pBuf);
//  204       break;
//  205 
//  206     case MT_UTIL_SRC_MATCH_DEL_ENTRY:
//  207       MT_UtilSrcMatchDeleteEntry(pBuf);
//  208       break;
//  209 
//  210     case MT_UTIL_SRC_MATCH_CHECK_SRC_ADDR:
//  211       MT_UtilSrcMatchCheckSrcAddr(pBuf);
//  212       break;
//  213 
//  214     case MT_UTIL_SRC_MATCH_ACK_ALL_PENDING:
//  215       MT_UtilSrcMatchAckAllPending(pBuf);
//  216       break;
//  217 
//  218     case MT_UTIL_SRC_MATCH_CHECK_ALL_PENDING:
//  219       MT_UtilSrcMatchCheckAllPending(pBuf);
//  220       break;
//  221 
//  222     case MT_UTIL_TEST_LOOPBACK:
//  223       MT_BuildAndSendZToolResponse((MT_RPC_CMD_SRSP|(uint8)MT_RPC_SYS_UTIL), MT_UTIL_TEST_LOOPBACK,
//  224                                     pBuf[MT_RPC_POS_LEN], (pBuf+MT_RPC_FRAME_HDR_SZ));
//  225       break;
//  226 
//  227 #if !defined NONWK
//  228     case MT_UTIL_DATA_REQ:
//  229       MT_UtilDataReq(pBuf);
//  230       break;
//  231 
//  232     case MT_UTIL_ADDRMGR_EXT_ADDR_LOOKUP:
//  233       MT_UtilAddrMgrExtAddrLookup(pBuf);
//  234       break;
//  235 
//  236     case MT_UTIL_ADDRMGR_NWK_ADDR_LOOKUP:
//  237       MT_UtilAddrMgrEntryLookupNwk(pBuf);
//  238       break;
//  239 
//  240 #if defined MT_SYS_KEY_MANAGEMENT
//  241     case MT_UTIL_APSME_LINK_KEY_DATA_GET:
//  242       MT_UtilAPSME_LinkKeyDataGet(pBuf);
//  243       break;
//  244 
//  245     case MT_UTIL_APSME_LINK_KEY_NV_ID_GET:
//  246       MT_UtilAPSME_LinkKeyNvIdGet(pBuf);
//  247       break;
//  248 #endif // MT_SYS_KEY_MANAGEMENT
//  249 
//  250     case MT_UTIL_ASSOC_COUNT:
//  251       MT_UtilAssocCount(pBuf);
//  252       break;
//  253 
//  254     case MT_UTIL_ASSOC_FIND_DEVICE:
//  255       MT_UtilAssocFindDevice(pBuf);
//  256       break;
//  257 
//  258     case MT_UTIL_ASSOC_GET_WITH_ADDRESS:
//  259       MT_UtilAssocGetWithAddress(pBuf);
//  260       break;
//  261 
//  262 #if defined ZCL_KEY_ESTABLISH
//  263     case MT_UTIL_ZCL_KEY_EST_INIT_EST:
//  264       MT_UtilzclGeneral_KeyEstablish_InitiateKeyEstablishment(pBuf);
//  265       break;
//  266 
//  267     case MT_UTIL_ZCL_KEY_EST_SIGN:
//  268       MT_UtilzclGeneral_KeyEstablishment_ECDSASign(pBuf);
//  269       break;
//  270 #endif
//  271 
//  272     case MT_UTIL_SYNC_REQ:
//  273       MT_UtilSync();
//  274       break;
//  275 #endif /* !defined NONWK */
//  276 
//  277     default:
//  278       status = MT_RPC_ERR_COMMAND_ID;
//  279       break;
//  280   }
//  281 
//  282   return status;
//  283 }
//  284 
//  285 /***************************************************************************************************
//  286  * @fn      MT_UtilGetDeviceInfo
//  287  *
//  288  * @brief   The Get Device Info serial message.
//  289  *
//  290  * @param   None.
//  291  *
//  292  * @return  void
//  293  ***************************************************************************************************/
//  294 void MT_UtilGetDeviceInfo(void)
//  295 {
//  296   uint8  *buf;
//  297   uint8  *pBuf;
//  298   uint8  bufLen = MT_UTIL_DEVICE_INFO_RESPONSE_LEN;
//  299   uint16 *assocList = NULL;
//  300 
//  301 #if !defined NONWK
//  302   uint8  assocCnt = 0;
//  303 
//  304   if (ZG_DEVICE_RTR_TYPE)
//  305   {
//  306     assocList = AssocMakeList( &assocCnt );
//  307     bufLen += (assocCnt * sizeof(uint16));
//  308   }
//  309 #endif
//  310 
//  311   buf = osal_mem_alloc( bufLen );
//  312   if ( buf )
//  313   {
//  314     pBuf = buf;
//  315 
//  316     *pBuf++ = ZSUCCESS; // Status
//  317 
//  318     osal_nv_read( ZCD_NV_EXTADDR, 0, Z_EXTADDR_LEN, pBuf );
//  319     pBuf += Z_EXTADDR_LEN;
//  320 
//  321 #if defined NONWK
//  322     // Skip past ZStack only parameters for NONWK
//  323     *pBuf++ = 0;
//  324     *pBuf++ = 0;
//  325     *pBuf++ = 0;
//  326     *pBuf++ = 0;
//  327     *pBuf = 0;
//  328 #else
//  329     {
//  330       uint16 shortAddr = NLME_GetShortAddr();
//  331       *pBuf++ = LO_UINT16( shortAddr );
//  332       *pBuf++ = HI_UINT16( shortAddr );
//  333     }
//  334 
//  335     /* Return device type */
//  336     *pBuf++ = ZSTACK_DEVICE_BUILD;
//  337 
//  338     /*Return device state */
//  339     *pBuf++ = (uint8)devState;
//  340 
//  341     if (ZG_DEVICE_RTR_TYPE)
//  342     {
//  343       *pBuf++ = assocCnt;
//  344 
//  345       if ( assocCnt )
//  346       {
//  347         uint8 x;
//  348         uint16 *puint16 = assocList;
//  349 
//  350         for ( x = 0; x < assocCnt; x++, puint16++ )
//  351         {
//  352           *pBuf++ = LO_UINT16( *puint16 );
//  353           *pBuf++ = HI_UINT16( *puint16 );
//  354         }
//  355       }
//  356     }
//  357     else
//  358     {
//  359       *pBuf++ = 0;
//  360     }
//  361 #endif
//  362 
//  363     MT_BuildAndSendZToolResponse( ((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL),
//  364                                  MT_UTIL_GET_DEVICE_INFO,
//  365                                  bufLen, buf );
//  366 
//  367     osal_mem_free( buf );
//  368   }
//  369 
//  370   if ( assocList )
//  371   {
//  372     osal_mem_free( assocList );
//  373   }
//  374 }
//  375 
//  376 /***************************************************************************************************
//  377  * @fn      MT_UtilGetNvInfo
//  378  *
//  379  * @brief   The Get NV Info serial message.
//  380  *
//  381  * @param   None.
//  382  *
//  383  * @return  void
//  384  ***************************************************************************************************/
//  385 void MT_UtilGetNvInfo(void)
//  386 {
//  387   uint8 len;
//  388   uint8 stat;
//  389   uint8 *buf;
//  390   uint8 *pBuf;
//  391   uint16 tmp16;
//  392   uint32 tmp32;
//  393 
//  394   /*
//  395     Get required length of buffer
//  396     Status + ExtAddr + ChanList + PanID  + SecLevel + PreCfgKey
//  397   */
//  398   len = 1 + Z_EXTADDR_LEN + 4 + 2 + 1 + SEC_KEY_LEN;
//  399 
//  400   buf = osal_mem_alloc( len );
//  401   if ( buf )
//  402   {
//  403     /* Assume NV not available */
//  404     osal_memset( buf, 0xFF, len );
//  405 
//  406     /* Skip over status */
//  407     pBuf = buf + 1;
//  408 
//  409     /* Start with 64-bit extended address */
//  410     stat = osal_nv_read( ZCD_NV_EXTADDR, 0, Z_EXTADDR_LEN, pBuf );
//  411     if ( stat ) stat = 0x01;
//  412     pBuf += Z_EXTADDR_LEN;
//  413 
//  414     /* Scan channel list (bit mask) */
//  415     if (  osal_nv_read( ZCD_NV_CHANLIST, 0, sizeof( tmp32 ), &tmp32 ) )
//  416       stat |= 0x02;
//  417     else
//  418     {
//  419       pBuf[0] = BREAK_UINT32( tmp32, 3 );
//  420       pBuf[1] = BREAK_UINT32( tmp32, 2 );
//  421       pBuf[2] = BREAK_UINT32( tmp32, 1 );
//  422       pBuf[3] = BREAK_UINT32( tmp32, 0 );
//  423     }
//  424     pBuf += sizeof( tmp32 );
//  425 
//  426     /* ZigBee PanID */
//  427     if ( osal_nv_read( ZCD_NV_PANID, 0, sizeof( tmp16 ), &tmp16 ) )
//  428       stat |= 0x04;
//  429     else
//  430     {
//  431       pBuf[0] = LO_UINT16( tmp16 );
//  432       pBuf[1] = HI_UINT16( tmp16 );
//  433     }
//  434     pBuf += sizeof( tmp16 );
//  435 
//  436     /* Security level */
//  437     if ( osal_nv_read( ZCD_NV_SECURITY_LEVEL, 0, sizeof( uint8 ), pBuf++ ) )
//  438       stat |= 0x08;
//  439 
//  440     /* Pre-configured security key */
//  441     if ( osal_nv_read( ZCD_NV_PRECFGKEY, 0, SEC_KEY_LEN, pBuf ) )
//  442       stat |= 0x10;
//  443 
//  444     /* Status bit mask - bit=1 indicates failure */
//  445     *buf = stat;
//  446 
//  447     MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), MT_UTIL_GET_NV_INFO,
//  448                                   len, buf );
//  449 
//  450     osal_mem_free( buf );
//  451   }
//  452 }
//  453 
//  454 /***************************************************************************************************
//  455  * @fn      MT_UtilSetPanID
//  456  *
//  457  * @brief   Set PanID message
//  458  *
//  459  * @param   pBuf - pointer to the data
//  460  *
//  461  * @return  void
//  462  ***************************************************************************************************/
//  463 void MT_UtilSetPanID(uint8 *pBuf)
//  464 {
//  465   uint16 temp16;
//  466   uint8 retValue = ZFailure;
//  467   uint8 cmdId;
//  468 
//  469   /* parse header */
//  470   cmdId = pBuf[MT_RPC_POS_CMD1];
//  471   pBuf += MT_RPC_FRAME_HDR_SZ;
//  472 
//  473   temp16 = BUILD_UINT16(pBuf[0], pBuf[1]);
//  474   pBuf += sizeof(uint16);
//  475 
//  476   retValue = osal_nv_write(ZCD_NV_PANID, 0, osal_nv_item_len( ZCD_NV_PANID ), &temp16);
//  477 
//  478   /* Build and send back the response */
//  479   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue);
//  480 }
//  481 
//  482 /***************************************************************************************************
//  483  * @fn      MT_UtilSetChannels
//  484  *
//  485  * @brief   Set Channels
//  486  *
//  487  * @param   pBuf - pointer to the data
//  488  *
//  489  * @return  void
//  490  ***************************************************************************************************/
//  491 void MT_UtilSetChannels(uint8 *pBuf)
//  492 {
//  493   uint32 tmp32;
//  494   uint8 retValue = ZFailure;
//  495   uint8 cmdId;
//  496 
//  497   /* parse header */
//  498   cmdId = pBuf[MT_RPC_POS_CMD1];
//  499   pBuf += MT_RPC_FRAME_HDR_SZ;
//  500 
//  501   tmp32 = BUILD_UINT32(pBuf[0], pBuf[1], pBuf[2], pBuf[3]);
//  502 
//  503   retValue = osal_nv_write(ZCD_NV_CHANLIST, 0, osal_nv_item_len( ZCD_NV_CHANLIST ), &tmp32);
//  504 
//  505   /* Build and send back the response */
//  506   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue);
//  507 }
//  508 
//  509 /***************************************************************************************************
//  510  * @fn      MT_UtilSetSecLevel
//  511  *
//  512  * @brief   Set Sec Level
//  513  *
//  514  * @param   byte *msg - pointer to the data
//  515  *
//  516  * @return  void
//  517  ***************************************************************************************************/
//  518 void MT_UtilSetSecLevel(uint8 *pBuf)
//  519 {
//  520   uint8 retValue = ZFailure;
//  521   uint8 cmdId;
//  522 
//  523   /* parse header */
//  524   cmdId = pBuf[MT_RPC_POS_CMD1];
//  525   pBuf += MT_RPC_FRAME_HDR_SZ;
//  526 
//  527   retValue = osal_nv_write( ZCD_NV_SECURITY_LEVEL, 0, osal_nv_item_len( ZCD_NV_SECURITY_LEVEL ), pBuf);
//  528 
//  529   /* Build and send back the response */
//  530   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
//  531 
//  532 }
//  533 
//  534 /***************************************************************************************************
//  535  * @fn      MT_UtilSetPreCfgKey
//  536  *
//  537  * @brief   Set Pre Cfg Key
//  538  *
//  539  * @param   pBuf - pointer to the data
//  540  *
//  541  * @return  void
//  542  ***************************************************************************************************/
//  543 void MT_UtilSetPreCfgKey(uint8 *pBuf)
//  544 {
//  545   uint8 retValue = ZFailure;
//  546   uint8 cmdId;
//  547 
//  548   /* parse header */
//  549   cmdId = pBuf[MT_RPC_POS_CMD1];
//  550   pBuf += MT_RPC_FRAME_HDR_SZ;
//  551 
//  552   retValue = osal_nv_write( ZCD_NV_PRECFGKEY, 0, osal_nv_item_len( ZCD_NV_PRECFGKEY ), pBuf);
//  553 
//  554   /* Build and send back the response */
//  555   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
//  556 
//  557 }
//  558 
//  559 /***************************************************************************************************
//  560  * @fn      MT_UtilCallbackSub
//  561  *
//  562  * @brief   The Callback subscribe.
//  563  *
//  564  * @param   pBuf - pointer to the data
//  565  *
//  566  * @return  void
//  567  ***************************************************************************************************/
//  568 void MT_UtilCallbackSub(uint8 *pBuf)
//  569 {
//  570   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
//  571   uint8 retValue = ZFailure;
//  572 
//  573 #if defined(MT_MAC_CB_FUNC) || defined(MT_NWK_CB_FUNC) || defined(MT_ZDO_CB_FUNC) || defined(MT_AF_CB_FUNC) || defined(MT_SAPI_CB_FUNC)
//  574   uint8 subSystem;
//  575   uint16 subscribed_command;
//  576 
//  577   // Move past header
//  578   retValue = ZSuccess;
//  579   pBuf += MT_RPC_FRAME_HDR_SZ;
//  580 
//  581   /* Command */
//  582   subscribed_command = BUILD_UINT16(pBuf[0], pBuf[1]);
//  583   pBuf += 2;
//  584 
//  585   /* Subsystem - 5 bits on the MSB of the command */
//  586   subSystem = HI_UINT16(subscribed_command) & 0x1F ;
//  587 
//  588   /* What is the action - SUBSCRIBE or !SUBSCRIBE */
//  589   if (*pBuf)
//  590   {
//  591     /* Turn ON */
//  592   #if defined( MT_MAC_CB_FUNC )
//  593     if ((subSystem == MT_RPC_SYS_MAC) || (subscribed_command == 0xFFFF))
//  594       _macCallbackSub = 0xFFFF;
//  595   #endif
//  596 
//  597   #if defined( MT_NWK_CB_FUNC )
//  598     if ((subSystem == MT_RPC_SYS_NWK) || (subscribed_command == 0xFFFF))
//  599       _nwkCallbackSub = 0xFFFF;
//  600   #endif
//  601 
//  602   #if defined( MT_ZDO_CB_FUNC )
//  603     if ((subSystem == MT_RPC_SYS_ZDO) || (subscribed_command == 0xFFFF))
//  604       _zdoCallbackSub = 0xFFFFFFFF;
//  605   #endif
//  606 
//  607   #if defined( MT_AF_CB_FUNC )
//  608     if ((subSystem == MT_RPC_SYS_AF) || (subscribed_command == 0xFFFF))
//  609       _afCallbackSub = 0xFFFF;
//  610   #endif
//  611 
//  612   #if defined( MT_SAPI_CB_FUNC )
//  613     if ((subSystem == MT_RPC_SYS_SAPI) || (subscribed_command == 0xFFFF))
//  614       _sapiCallbackSub = 0xFFFF;
//  615   #endif
//  616   }
//  617   else
//  618   {
//  619     /* Turn OFF */
//  620   #if defined( MT_MAC_CB_FUNC )
//  621     if ((subSystem == MT_RPC_SYS_MAC) || (subscribed_command == 0xFFFF))
//  622       _macCallbackSub = 0x0000;
//  623   #endif
//  624 
//  625   #if defined( MT_NWK_CB_FUNC )
//  626     if ((subSystem == MT_RPC_SYS_NWK) || (subscribed_command == 0xFFFF))
//  627       _nwkCallbackSub = 0x0000;
//  628   #endif
//  629 
//  630   #if defined( MT_ZDO_CB_FUNC )
//  631     if ((subSystem == MT_RPC_SYS_ZDO) || (subscribed_command == 0xFFFF))
//  632       _zdoCallbackSub = 0x00000000;
//  633   #endif
//  634 
//  635   #if defined( MT_AF_CB_FUNC )
//  636     if ((subSystem == MT_RPC_SYS_AF) || (subscribed_command == 0xFFFF))
//  637       _afCallbackSub = 0x0000;
//  638   #endif
//  639 
//  640   #if defined( MT_SAPI_CB_FUNC )
//  641     if ((subSystem == MT_RPC_SYS_SAPI) || (subscribed_command == 0xFFFF))
//  642         _sapiCallbackSub = 0x0000;
//  643   #endif
//  644   }
//  645 #endif  // MT_MAC_CB_FUNC || MT_NWK_CB_FUNC || MT_ZDO_CB_FUNC || MT_AF_CB_FUNC || MT_SAPI_CB_FUNC || MT_SAPI_CB_FUNC
//  646 
//  647   /* Build and send back the response */
//  648   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
//  649 }
//  650 
//  651 #if (defined HAL_KEY) && (HAL_KEY == TRUE)
//  652 /***************************************************************************************************
//  653  * @fn      MT_UtilKeyEvent
//  654  *
//  655  * @brief   Process Key Event
//  656  *
//  657  * @param   pBuf - pointer to the data
//  658  *
//  659  * @return  void
//  660  ***************************************************************************************************/
//  661 void MT_UtilKeyEvent(uint8 *pBuf)
//  662 {
//  663   uint8 x = 0;
//  664   uint8 retValue = ZFailure;
//  665   uint8 cmdId;
//  666 
//  667   /* parse header */
//  668   cmdId = pBuf[MT_RPC_POS_CMD1];
//  669   pBuf += MT_RPC_FRAME_HDR_SZ;
//  670 
//  671   /* Translate between SPI values to device values */
//  672   if ( *pBuf & 0x01 )
//  673     x |= HAL_KEY_SW_1;
//  674   if ( *pBuf & 0x02 )
//  675     x |= HAL_KEY_SW_2;
//  676   if ( *pBuf & 0x04 )
//  677     x |= HAL_KEY_SW_3;
//  678   if ( *pBuf & 0x08 )
//  679   x |= HAL_KEY_SW_4;
//  680 #if defined ( HAL_KEY_SW_5 )
//  681   if ( *pBuf & 0x10 )
//  682     x |= HAL_KEY_SW_5;
//  683 #endif
//  684 #if defined ( HAL_KEY_SW_6 )
//  685   if ( *pBuf & 0x20 )
//  686     x |= HAL_KEY_SW_6;
//  687 #endif
//  688 #if defined ( HAL_KEY_SW_7 )
//  689   if ( *pBuf & 0x40 )
//  690     x |= HAL_KEY_SW_7;
//  691 #endif
//  692 #if defined ( HAL_KEY_SW_8 )
//  693   if ( *pBuf & 0x80 )
//  694     x |= HAL_KEY_SW_8;
//  695 #endif
//  696   pBuf++;
//  697 
//  698   retValue = OnBoard_SendKeys(x, *pBuf);
//  699 
//  700   /* Build and send back the response */
//  701   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
//  702 }
//  703 #endif
//  704 
//  705 /***************************************************************************************************
//  706  * @fn      MT_UtilTimeAlive
//  707  *
//  708  * @brief   Process Time Alive
//  709  *
//  710  * @param   None.
//  711  *
//  712  * @return  None
//  713  ***************************************************************************************************/
//  714 void MT_UtilTimeAlive(void)
//  715 {
//  716   uint8 timeAlive[4];
//  717   uint32 tmp32;
//  718 
//  719   /* Time since last reset (seconds) */
//  720   tmp32 = osal_GetSystemClock() / 1000;
//  721 
//  722   /* Convert to high byte first into temp buffer */
//  723   timeAlive[0] = BREAK_UINT32(tmp32, 0);
//  724   timeAlive[1] = BREAK_UINT32(tmp32, 1);
//  725   timeAlive[2] = BREAK_UINT32(tmp32, 2);
//  726   timeAlive[3] = BREAK_UINT32(tmp32, 3);
//  727 
//  728   /* Build and send back the response */
//  729   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL),
//  730                                        MT_UTIL_TIME_ALIVE, sizeof(timeAlive), timeAlive);
//  731 }
//  732 
//  733 #if (defined HAL_LED) && (HAL_LED == TRUE)
//  734 /***************************************************************************************************
//  735  * @fn      MT_UtilLedControl
//  736  *
//  737  * @brief   Process the LED Control Message
//  738  *
//  739  * @param   pBuf - pointer to the received data
//  740  *
//  741  * @return  None
//  742  ***************************************************************************************************/
//  743 void MT_UtilLedControl(uint8 *pBuf)
//  744 {
//  745   uint8 iLed, Led, iMode, Mode, cmdId;
//  746   uint8 retValue = ZFailure;
//  747 
//  748   /* parse header */
//  749   cmdId = pBuf[MT_RPC_POS_CMD1];
//  750   pBuf += MT_RPC_FRAME_HDR_SZ;
//  751 
//  752   /* LED and Mode */
//  753   iLed = *pBuf++;
//  754   iMode = *pBuf;
//  755 
//  756   if ( iLed == 1 )
//  757     Led = HAL_LED_1;
//  758   else if ( iLed == 2 )
//  759     Led = HAL_LED_2;
//  760   else if ( iLed == 3 )
//  761     Led = HAL_LED_3;
//  762   else if ( iLed == 4 )
//  763     Led = HAL_LED_4;
//  764   else if ( iLed == 0xFF )
//  765     Led = HAL_LED_ALL;
//  766   else
//  767     Led = 0;
//  768 
//  769   if ( iMode == 0 )
//  770     Mode = HAL_LED_MODE_OFF;
//  771   else if ( iMode == 1 )
//  772     Mode = HAL_LED_MODE_ON;
//  773   else if ( iMode == 2 )
//  774     Mode = HAL_LED_MODE_BLINK;
//  775   else if ( iMode == 3 )
//  776     Mode = HAL_LED_MODE_FLASH;
//  777   else if ( iMode == 4 )
//  778     Mode = HAL_LED_MODE_TOGGLE;
//  779   else
//  780     Led = 0;
//  781 
//  782   if ( Led != 0 )
//  783   {
//  784     HalLedSet (Led, Mode);
//  785     retValue = ZSuccess;
//  786   }
//  787 
//  788   /* Build and send back the response */
//  789   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
//  790 }
//  791 #endif /* HAL_LED */
//  792 
//  793 
//  794 /***************************************************************************************************
//  795  * @fn          MT_UtilSrcMatchEnable
//  796  *
//  797  * @brief      Enabled AUTOPEND and source address matching.
//  798  *
//  799  * @param      pBuf - Buffer contains the data
//  800  *
//  801  * @return     void
//  802  ***************************************************************************************************/
//  803 void MT_UtilSrcMatchEnable (uint8 *pBuf)
//  804 {
//  805   uint8 retValue, cmdId;
//  806 
//  807   /* Parse header */
//  808   cmdId = pBuf[MT_RPC_POS_CMD1];
//  809   pBuf += MT_RPC_FRAME_HDR_SZ;
//  810 
//  811 #ifdef AUTO_PEND
//  812   /* Call the routine */
//  813   retValue = ZMacSrcMatchEnable (pBuf[0], pBuf[1]);
//  814 #else
//  815   retValue = ZMacUnsupported;
//  816 #endif
//  817 
//  818   /* Build and send back the response */
//  819   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
//  820 
//  821 }
//  822 
//  823 /***************************************************************************************************
//  824  * @fn          MT_UtilSrcMatchAddEntry
//  825  *
//  826  * @brief       Add a short or extended address to source address table.
//  827  *
//  828  * @param       pBuf - Buffer contains the data
//  829  *
//  830  * @return      void
//  831  ***************************************************************************************************/
//  832 void MT_UtilSrcMatchAddEntry (uint8 *pBuf)
//  833 {
//  834   uint8 retValue, cmdId;
//  835 
//  836   /* Parse header */
//  837   cmdId = pBuf[MT_RPC_POS_CMD1];
//  838   pBuf += MT_RPC_FRAME_HDR_SZ;
//  839 
//  840 #ifdef AUTO_PEND
//  841   uint16 panID;
//  842   zAddrType_t devAddr;
//  843 
//  844   /* Address mode */
//  845   devAddr.addrMode = *pBuf++;
//  846 
//  847   /* Address based on the address mode */
//  848   MT_UtilSpi2Addr( &devAddr, pBuf);
//  849   pBuf += Z_EXTADDR_LEN;
//  850 
//  851   /* PanID */
//  852   panID = BUILD_UINT16( pBuf[0] , pBuf[1] );
//  853 
//  854   /* Call the routine */
//  855   retValue =  ZMacSrcMatchAddEntry (&devAddr, panID);
//  856 #else
//  857   retValue = ZMacUnsupported;
//  858 #endif
//  859 
//  860   /* Build and send back the response */
//  861   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
//  862 }
//  863 
//  864 /***************************************************************************************************
//  865  * @fn          MT_UtilSrcMatchDeleteEntry
//  866  *
//  867  * @brief      Delete a short or extended address from source address table.
//  868  *
//  869  * @param      pBuf - Buffer contains the data
//  870  *
//  871  * @return     void
//  872  ***************************************************************************************************/
//  873 void MT_UtilSrcMatchDeleteEntry (uint8 *pBuf)
//  874 {
//  875   uint8 retValue, cmdId;
//  876 
//  877   /* Parse header */
//  878   cmdId = pBuf[MT_RPC_POS_CMD1];
//  879   pBuf += MT_RPC_FRAME_HDR_SZ;
//  880 
//  881 #ifdef AUTO_PEND
//  882   uint16 panID;
//  883   zAddrType_t devAddr;
//  884 
//  885   /* Address mode */
//  886   devAddr.addrMode = *pBuf++;
//  887 
//  888   /* Address based on the address mode */
//  889   MT_UtilSpi2Addr( &devAddr, pBuf);
//  890   pBuf += Z_EXTADDR_LEN;
//  891 
//  892   /* PanID */
//  893   panID = BUILD_UINT16( pBuf[0] , pBuf[1] );
//  894 
//  895   /* Call the routine */
//  896   retValue =  ZMacSrcMatchDeleteEntry (&devAddr, panID);
//  897 #else
//  898   retValue = ZMacUnsupported;
//  899 #endif
//  900 
//  901   /* Build and send back the response */
//  902   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
//  903 }
//  904 
//  905 /***************************************************************************************************
//  906  * @fn          MT_UtilSrcMatchCheckSrcAddr
//  907  *
//  908  * @brief      Check if a short or extended address is in the source address table.
//  909  *
//  910  * @param      pBuf - Buffer contains the data
//  911  *
//  912  * @return     void
//  913  ***************************************************************************************************/
//  914 void MT_UtilSrcMatchCheckSrcAddr (uint8 *pBuf)
//  915 {
//  916   uint8 cmdId;
//  917   uint8 retArray[2];
//  918 
//  919   /* Parse header */
//  920   cmdId = pBuf[MT_RPC_POS_CMD1];
//  921   pBuf += MT_RPC_FRAME_HDR_SZ;
//  922 
//  923 #if 0  /* Unsupported  */
//  924   uint16 panID;
//  925   zAddrType_t devAddr;
//  926 
//  927   /* Address mode */
//  928   devAddr.addrMode = *pBuf++;
//  929 
//  930   /* Address based on the address mode */
//  931   MT_UtilSpi2Addr( &devAddr, pBuf);
//  932   pBuf += Z_EXTADDR_LEN;
//  933 
//  934   /* PanID */
//  935   panID = BUILD_UINT16( pBuf[0] , pBuf[1] );
//  936 
//  937   /* Call the routine */
//  938   retArray[1] =  ZMacSrcMatchCheckSrcAddr (&devAddr, panID);
//  939 
//  940     /* Return failure if the index is invalid */
//  941   if (retArray[1] == ZMacSrcMatchInvalidIndex )
//  942   {
//  943     retArray[0] = ZFailure;
//  944   }
//  945   else
//  946   {
//  947     retArray[0] = ZSuccess;
//  948   }
//  949 #else
//  950   retArray[0] = ZMacUnsupported;
//  951   retArray[1] = ZMacSrcMatchInvalidIndex;
//  952 #endif
//  953 
//  954   /* Build and send back the response */
//  955   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 2, retArray );
//  956 }
//  957 
//  958 /***************************************************************************************************
//  959  * @fn          MT_UtilSrcMatchAckAllPending
//  960  *
//  961  * @brief       Enabled/disable acknowledging all packets with pending bit set
//  962  *              It is normally enabled when adding new entries to
//  963  *              the source address table fails due to the table is full, or
//  964  *              disabled when more entries are deleted and the table has
//  965  *              empty slots.
//  966  *
//  967  * @param       pBuf - Buffer contains the data
//  968  *
//  969  * @return      void
//  970  ***************************************************************************************************/
//  971 void MT_UtilSrcMatchAckAllPending (uint8 *pBuf)
//  972 {
//  973   uint8 retValue, cmdId;
//  974 
//  975   /* Parse header */
//  976   cmdId = pBuf[MT_RPC_POS_CMD1];
//  977   pBuf += MT_RPC_FRAME_HDR_SZ;
//  978 
//  979 #ifdef AUTO_PEND
//  980   /* Call the routine */
//  981   retValue = ZMacSrcMatchAckAllPending(*pBuf);
//  982 #else
//  983   retValue = ZMacUnsupported;
//  984 #endif
//  985 
//  986   /* Build and send back the response */
//  987   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
//  988 }
//  989 
//  990 /***************************************************************************************************
//  991  * @fn          MT_UtilSrcMatchCheckAllPending
//  992  *
//  993  * @brief       Check if acknowledging all packets with pending bit set
//  994  *              is enabled.
//  995  *
//  996  * @param       pBuf - Buffer contains the data
//  997  *
//  998  * @return      void
//  999  ***************************************************************************************************/
// 1000 void MT_UtilSrcMatchCheckAllPending (uint8 *pBuf)
// 1001 {
// 1002   uint8 retArray[2], cmdId;
// 1003 
// 1004   /* Parse header */
// 1005   cmdId = pBuf[MT_RPC_POS_CMD1];
// 1006   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1007 
// 1008 #ifdef AUTO_PEND
// 1009   /* Call the routine */
// 1010   retArray[0] = ZMacSuccess;
// 1011   retArray[1] = ZMacSrcMatchCheckAllPending();
// 1012 #else
// 1013   retArray[0] = ZMacUnsupported;
// 1014   retArray[1] = FALSE;
// 1015 #endif
// 1016 
// 1017   /* Build and send back the response */
// 1018   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 2, retArray );
// 1019 }
// 1020 
// 1021 /***************************************************************************************************
// 1022  * SUPPORT
// 1023  ***************************************************************************************************/
// 1024 
// 1025 #ifdef AUTO_PEND
// 1026 /***************************************************************************************************
// 1027  * @fn      MT_UtilRevExtCpy
// 1028  *
// 1029  * @brief
// 1030  *
// 1031  *   Reverse-copy an extended address.
// 1032  *
// 1033  * @param   pDst - Pointer to data destination
// 1034  * @param   pSrc - Pointer to data source
// 1035  *
// 1036  * @return  void
// 1037  ***************************************************************************************************/
// 1038 static void MT_UtilRevExtCpy( uint8 *pDst, uint8 *pSrc )
// 1039 {
// 1040   int8 i;
// 1041 
// 1042   for ( i = Z_EXTADDR_LEN - 1; i >= 0; i-- )
// 1043   {
// 1044     *pDst++ = pSrc[i];
// 1045   }
// 1046 }
// 1047 
// 1048 /***************************************************************************************************
// 1049  * @fn      MT_UtilSpi2Addr
// 1050  *
// 1051  * @brief   Copy an address from an SPI message to an address struct.  The
// 1052  *          addrMode in pAddr must already be set.
// 1053  *
// 1054  * @param   pDst - Pointer to address struct
// 1055  * @param   pSrc - Pointer SPI message byte array
// 1056  *
// 1057  * @return  void
// 1058  ***************************************************************************************************/
// 1059 static void MT_UtilSpi2Addr( zAddrType_t *pDst, uint8 *pSrc )
// 1060 {
// 1061   if ( pDst->addrMode == Addr16Bit )
// 1062   {
// 1063     pDst->addr.shortAddr = BUILD_UINT16( pSrc[0] , pSrc[1] );
// 1064   }
// 1065   else if ( pDst->addrMode == Addr64Bit )
// 1066   {
// 1067     MT_UtilRevExtCpy( pDst->addr.extAddr, pSrc );
// 1068   }
// 1069 }
// 1070 #endif // AUTO_PEND
// 1071 
// 1072 #if !defined NONWK
// 1073 /**************************************************************************************************
// 1074  * @fn      MT_UtilDataReq
// 1075  *
// 1076  * @brief   Process the MAC Data Request command.
// 1077  *
// 1078  * @param   pBuf - pointer to the received data
// 1079  *
// 1080  * @return  None
// 1081 **************************************************************************************************/
// 1082 void MT_UtilDataReq(uint8 *pBuf)
// 1083 {
// 1084   uint8 rtrn = NwkPollReq(pBuf[MT_RPC_POS_DAT0]);
// 1085   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), MT_UTIL_DATA_REQ,
// 1086                                                                                1, &rtrn);
// 1087 }
// 1088 
// 1089 /***************************************************************************************************
// 1090  * @fn      MT_UtilAddrMgrExtAddrLookup
// 1091  *
// 1092  * @brief   Proxy the AddrMgrExtAddrLookup() function.
// 1093  *
// 1094  * @param   pBuf - pointer to the received buffer
// 1095  *
// 1096  * @return  void
// 1097  ***************************************************************************************************/
// 1098 static void MT_UtilAddrMgrExtAddrLookup(uint8 *pBuf)
// 1099 {
// 1100   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1101   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1102 
// 1103   (void)AddrMgrExtAddrLookup(BUILD_UINT16(pBuf[Z_EXTADDR_LEN], pBuf[Z_EXTADDR_LEN+1]), pBuf);
// 1104   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
// 1105                                                                Z_EXTADDR_LEN, (uint8 *)pBuf);
// 1106 }
// 1107 
// 1108 /***************************************************************************************************
// 1109  * @fn      MT_UtilAddrMgrEntryLookupNwk
// 1110  *
// 1111  * @brief   Proxy the AddrMgrEntryLookupNwk() function.
// 1112  *
// 1113  * @param   pBuf - pointer to the received buffer
// 1114  *
// 1115  * @return  void
// 1116  ***************************************************************************************************/
// 1117 static void MT_UtilAddrMgrEntryLookupNwk(uint8 *pBuf)
// 1118 {
// 1119   AddrMgrEntry_t entry;
// 1120   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1121   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1122 
// 1123   entry.nwkAddr = BUILD_UINT16(pBuf[0], pBuf[1]);
// 1124   (void)AddrMgrEntryLookupNwk(&entry);
// 1125   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
// 1126                                                                   Z_EXTADDR_LEN, entry.extAddr);
// 1127 }
// 1128 
// 1129 #if defined MT_SYS_KEY_MANAGEMENT
// 1130 /***************************************************************************************************
// 1131  * @fn      MT_UtilAPSME_LinkKeyDataGet
// 1132  *
// 1133  * @brief   Retrieves APS Link Key data from NV.
// 1134  *
// 1135  * @param   pBuf - pointer to the received buffer
// 1136  *
// 1137  * @return  void
// 1138  ***************************************************************************************************/
// 1139 static void MT_UtilAPSME_LinkKeyDataGet(uint8 *pBuf)
// 1140 {
// 1141   uint8 rsp[MT_APSME_LINKKEY_GET_RSP_LEN];
// 1142   APSME_LinkKeyData_t *pData = NULL;
// 1143   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1144   uint16 apsLinkKeyNvId;
// 1145   uint32 *apsRxFrmCntr;
// 1146   uint32 *apsTxFrmCntr;
// 1147 
// 1148   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1149 
// 1150   *rsp = APSME_LinkKeyNVIdGet(pBuf, &apsLinkKeyNvId);
// 1151 
// 1152   if (SUCCESS == *rsp)
// 1153   {
// 1154     pData = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
// 1155 
// 1156     if (pData != NULL)
// 1157     {
// 1158       // retrieve key from NV
// 1159       if ( osal_nv_read( apsLinkKeyNvId, 0,
// 1160                         sizeof(APSME_LinkKeyData_t), pData) == SUCCESS)
// 1161 
// 1162       {
// 1163         apsRxFrmCntr = &ApsLinkKeyFrmCntr[apsLinkKeyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].rxFrmCntr;
// 1164         apsTxFrmCntr = &ApsLinkKeyFrmCntr[apsLinkKeyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].txFrmCntr;
// 1165 
// 1166         uint8 *ptr = rsp+1;
// 1167         (void)osal_memcpy(ptr, pData->key, SEC_KEY_LEN);
// 1168         ptr += SEC_KEY_LEN;
// 1169         *ptr++ = BREAK_UINT32(*apsTxFrmCntr, 0);
// 1170         *ptr++ = BREAK_UINT32(*apsTxFrmCntr, 1);
// 1171         *ptr++ = BREAK_UINT32(*apsTxFrmCntr, 2);
// 1172         *ptr++ = BREAK_UINT32(*apsTxFrmCntr, 3);
// 1173         *ptr++ = BREAK_UINT32(*apsRxFrmCntr, 0);
// 1174         *ptr++ = BREAK_UINT32(*apsRxFrmCntr, 1);
// 1175         *ptr++ = BREAK_UINT32(*apsRxFrmCntr, 2);
// 1176         *ptr++ = BREAK_UINT32(*apsRxFrmCntr, 3);
// 1177       }
// 1178 
// 1179       // clear copy of key in RAM
// 1180       osal_memset( pData, 0x00, sizeof(APSME_LinkKeyData_t) );
// 1181 
// 1182       osal_mem_free(pData);
// 1183     }
// 1184   }
// 1185   else
// 1186   {
// 1187     // set data key and counters 0xFF
// 1188     osal_memset(&rsp[1], 0xFF, SEC_KEY_LEN + (MT_UTIL_FRM_CTR_LEN * 2));
// 1189   }
// 1190 
// 1191   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
// 1192                                        MT_APSME_LINKKEY_GET_RSP_LEN, rsp);
// 1193 
// 1194   // clear key data
// 1195   osal_memset(rsp, 0x00, MT_APSME_LINKKEY_GET_RSP_LEN);
// 1196 
// 1197 }
// 1198 
// 1199 /***************************************************************************************************
// 1200  * @fn      MT_UtilAPSME_LinkKeyNvIdGet
// 1201  *
// 1202  * @brief   Retrieves APS Link Key NV ID from the entry table.
// 1203  *
// 1204  * @param   pBuf - pointer to the received buffer
// 1205  *
// 1206  * @return  void
// 1207  ***************************************************************************************************/
// 1208 static void MT_UtilAPSME_LinkKeyNvIdGet(uint8 *pBuf)
// 1209 {
// 1210   uint8 rsp[MT_APSME_LINKKEY_NV_ID_GET_RSP_LEN];
// 1211   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1212   uint16 apsLinkKeyNvId;
// 1213 
// 1214   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1215 
// 1216   *rsp = APSME_LinkKeyNVIdGet(pBuf, &apsLinkKeyNvId);
// 1217 
// 1218   if (SUCCESS == *rsp)
// 1219   {
// 1220     rsp[1] = LO_UINT16(apsLinkKeyNvId);
// 1221     rsp[2] = HI_UINT16(apsLinkKeyNvId);
// 1222   }
// 1223   else
// 1224   {
// 1225     // send failure response with invalid NV ID
// 1226     osal_memset(&rsp[1], 0xFF, 2);
// 1227   }
// 1228 
// 1229   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
// 1230                                        MT_APSME_LINKKEY_NV_ID_GET_RSP_LEN, rsp);
// 1231 }
// 1232 #endif // MT_SYS_KEY_MANAGEMENT
// 1233 
// 1234 /***************************************************************************************************
// 1235  * @fn      MT_UtilAssocCount
// 1236  *
// 1237  * @brief   Proxy the AssocCount() function.
// 1238  *
// 1239  * @param   pBuf - pointer to the received buffer
// 1240  *
// 1241  * @return  void
// 1242  ***************************************************************************************************/
// 1243 static void MT_UtilAssocCount(uint8 *pBuf)
// 1244 {
// 1245   uint16 cnt;
// 1246   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1247   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1248 
// 1249   cnt = AssocCount(pBuf[0], pBuf[1]);
// 1250   pBuf[0] = LO_UINT16(cnt);
// 1251   pBuf[1] = HI_UINT16(cnt);
// 1252 
// 1253   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 2, pBuf);
// 1254 }
// 1255 
// 1256 /***************************************************************************************************
// 1257  * @fn      MT_UtilAssocFindDevice
// 1258  *
// 1259  * @brief   Get an associated device by index.
// 1260  *
// 1261  * @param   pBuf - pointer to the received buffer
// 1262  *
// 1263  * @return  void
// 1264  ***************************************************************************************************/
// 1265 static void MT_UtilAssocFindDevice(uint8 *pBuf)
// 1266 {
// 1267   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1268   uint8 buf[sizeof(associated_devices_t)];
// 1269 
// 1270   packDev_t(buf, AssocFindDevice(pBuf[MT_RPC_FRAME_HDR_SZ]));
// 1271   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
// 1272                                        sizeof(associated_devices_t), buf);
// 1273 }
// 1274 
// 1275 /***************************************************************************************************
// 1276  * @fn      MT_UtilAssocGetWithAddress
// 1277  *
// 1278  * @brief   Get an associated device by address.
// 1279  *
// 1280  * @param   pBuf - pointer to the received buffer
// 1281  *
// 1282  * @return  void
// 1283  ***************************************************************************************************/
// 1284 static void MT_UtilAssocGetWithAddress(uint8 *pBuf)
// 1285 {
// 1286   extern associated_devices_t *AssocGetWithAddress(uint8 *extAddr, uint16 shortAddr);
// 1287   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1288   uint8 buf[sizeof(associated_devices_t)];
// 1289 
// 1290   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1291   packDev_t(buf, AssocGetWithAddress(((AddrMgrExtAddrValid(pBuf)) ? pBuf : NULL),
// 1292                                   BUILD_UINT16(pBuf[Z_EXTADDR_LEN], pBuf[Z_EXTADDR_LEN+1])));
// 1293 
// 1294   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
// 1295                                        sizeof(associated_devices_t), buf);
// 1296 }
// 1297 
// 1298 /***************************************************************************************************
// 1299  * @fn      packDev_t
// 1300  *
// 1301  * @brief   Pack an associated_devices_t structure into a byte buffer (pack INVALID_NODE_ADDR if
// 1302  *          the pDev parameter is NULL).
// 1303  *
// 1304  * @param   pBuf - pointer to the buffer into which to pack the structure.
// 1305  * @param   pDev - pointer to the structure.
// 1306  *
// 1307  * @return  void
// 1308  ***************************************************************************************************/
// 1309 static void packDev_t(uint8 *pBuf, associated_devices_t *pDev)
// 1310 {
// 1311   if (NULL == pDev)
// 1312   {
// 1313     uint16 rtrn = INVALID_NODE_ADDR;
// 1314     *pBuf++ = LO_UINT16(rtrn);
// 1315     *pBuf++ = HI_UINT16(rtrn);
// 1316   }
// 1317   else
// 1318   {
// 1319     *pBuf++ = LO_UINT16(pDev->shortAddr);
// 1320     *pBuf++ = HI_UINT16(pDev->shortAddr);
// 1321     *pBuf++ = LO_UINT16(pDev->addrIdx);
// 1322     *pBuf++ = HI_UINT16(pDev->addrIdx);
// 1323     *pBuf++ = pDev->nodeRelation;
// 1324     *pBuf++ = pDev->devStatus;
// 1325     *pBuf++ = pDev->assocCnt;
// 1326     *pBuf++ = pDev->age;
// 1327     *pBuf++ = pDev->linkInfo.txCounter;
// 1328     *pBuf++ = pDev->linkInfo.txCost;
// 1329     *pBuf++ = pDev->linkInfo.rxLqi;
// 1330     *pBuf++ = pDev->linkInfo.inKeySeqNum;
// 1331     *pBuf++ = BREAK_UINT32(pDev->linkInfo.inFrmCntr, 0);
// 1332     *pBuf++ = BREAK_UINT32(pDev->linkInfo.inFrmCntr, 1);
// 1333     *pBuf++ = BREAK_UINT32(pDev->linkInfo.inFrmCntr, 2);
// 1334     *pBuf++ = BREAK_UINT32(pDev->linkInfo.inFrmCntr, 3);
// 1335     *pBuf++ = LO_UINT16(pDev->linkInfo.txFailure);
// 1336     *pBuf++ = HI_UINT16(pDev->linkInfo.txFailure);
// 1337   }
// 1338 }
// 1339 
// 1340 #if defined ZCL_KEY_ESTABLISH
// 1341 /***************************************************************************************************
// 1342  * @fn      MT_UtilzclGeneral_KeyEstablish_InitiateKeyEstablishment
// 1343  *
// 1344  * @brief   Proxy the zclGeneral_KeyEstablish_InitiateKeyEstablishment() function.
// 1345  *
// 1346  * @param   pBuf - pointer to the received buffer
// 1347  *
// 1348  * @return  void
// 1349  ***************************************************************************************************/
// 1350 static void MT_UtilzclGeneral_KeyEstablish_InitiateKeyEstablishment(uint8 *pBuf)
// 1351 {
// 1352   afAddrType_t partnerAddr;
// 1353   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1354   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1355 
// 1356   partnerAddr.panId = 0;  // Not an inter-pan message.
// 1357   partnerAddr.endPoint = pBuf[2];
// 1358   partnerAddr.addrMode = (afAddrMode_t)pBuf[3];
// 1359   if (afAddr64Bit == partnerAddr.addrMode)
// 1360   {
// 1361     (void)osal_memcpy(partnerAddr.addr.extAddr, pBuf+4, Z_EXTADDR_LEN);
// 1362   }
// 1363   else
// 1364   {
// 1365     partnerAddr.addr.shortAddr = BUILD_UINT16(pBuf[4], pBuf[5]);
// 1366   }
// 1367 
// 1368   zcl_key_establish_task_id = pBuf[0];
// 1369   *pBuf = zclGeneral_KeyEstablish_InitiateKeyEstablishment(MT_TaskID, &partnerAddr, pBuf[1]);
// 1370   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, pBuf);
// 1371 }
// 1372 
// 1373 /***************************************************************************************************
// 1374  * @fn      MT_UtilzclGeneral_KeyEstablishment_ECDSASign
// 1375  *
// 1376  * @brief   Proxy the zclGeneral_KeyEstablishment_ECDSASign() function.
// 1377  *
// 1378  * @param   pBuf - pointer to the received buffer
// 1379  *
// 1380  * @return  void
// 1381  ***************************************************************************************************/
// 1382 static void MT_UtilzclGeneral_KeyEstablishment_ECDSASign(uint8 *pBuf)
// 1383 {
// 1384 #if defined TC_LINKKEY_JOIN
// 1385   uint8 *output = osal_mem_alloc(SE_PROFILE_SIGNATURE_LENGTH+1);
// 1386   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1387   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1388 
// 1389   if (NULL == output)
// 1390   {
// 1391     *pBuf = FAILURE;
// 1392     MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, pBuf);
// 1393   }
// 1394   else
// 1395   {
// 1396     *output = zclGeneral_KeyEstablishment_ECDSASign(pBuf+1, *pBuf, output+1);
// 1397     MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
// 1398                                          SE_PROFILE_SIGNATURE_LENGTH+1, output);
// 1399     osal_mem_free(output);
// 1400   }
// 1401 #endif
// 1402 }
// 1403 
// 1404 /***************************************************************************************************
// 1405  * @fn      MT_UtilKeyEstablishInd
// 1406  *
// 1407  * @brief   Proxy the ZCL_KEY_ESTABLISH_IND command.
// 1408  *
// 1409  * @param   pInd - Pointer to a keyEstablishmentInd_t structure.
// 1410  *
// 1411  * @return  None
// 1412  ***************************************************************************************************/
// 1413 void MT_UtilKeyEstablishInd(keyEstablishmentInd_t *pInd)
// 1414 {
// 1415   uint8 msg[6];
// 1416 
// 1417   msg[0] = zcl_key_establish_task_id;
// 1418   msg[1] = pInd->hdr.event;
// 1419   msg[2] = pInd->hdr.status;
// 1420   msg[3] = pInd->waitTime;
// 1421   msg[4] = LO_UINT16(pInd->keyEstablishmentSuite);
// 1422   msg[5] = HI_UINT16(pInd->keyEstablishmentSuite);
// 1423 
// 1424   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_AREQ | (uint8)MT_RPC_SYS_UTIL),
// 1425                                        MT_UTIL_ZCL_KEY_ESTABLISH_IND, 6, msg);
// 1426 }
// 1427 #endif
// 1428 
// 1429 /***************************************************************************************************
// 1430  * @fn      MT_UtilSync
// 1431  *
// 1432  * @brief   Process the MT_UTIL_SYNC command
// 1433  *
// 1434  * @param   None
// 1435  *
// 1436  * @return  None
// 1437  ***************************************************************************************************/
// 1438 static void MT_UtilSync(void)
// 1439 {
// 1440  MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_AREQ|(uint8)MT_RPC_SYS_UTIL),MT_UTIL_SYNC_REQ,0,0);
// 1441 }
// 1442 #endif /* !defined NONWK */
// 1443 #endif /* MT_UTIL_FUNC */
// 1444 /**************************************************************************************************
// 1445  **************************************************************************************************/
// 
//
// 
//
//
//Errors: none
//Warnings: none
